<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF16">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeGods Christmas Wardrobe</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --christmas-red: #B91C1C; /* Deep Red 700 */
            --christmas-green: #065F46; /* Deep Green 700 */
            --bg-color-dark: #0f172a; /* Slate 900 for winter night background */
            --card-bg: #F0FDF4; /* Minty white for a snowy card feel */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color-dark);
            /* Subtle radial gradient for depth */
            background-image: radial-gradient(circle at top right, #1e3a8a 0%, #0f172a 50%); 
            color: white;
        }
        /* Custom Styling for the new theme */
        
        /* Main Text/Title Colors */
        .text-main-title {
            color: var(--christmas-red);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.4);
        }
        .text-h2-color, .text-h3-color {
            color: var(--christmas-green);
        }

        /* Card Backgrounds */
        .bg-card {
            background-color: var(--card-bg);
            border: 1px solid #D1FAE5; /* Light green border */
        }

        /* Button Styling */
        .trait-button {
            transition: all 0.2s;
            white-space: nowrap; 
            color: var(--christmas-green);
        }
        .trait-button:hover {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
            transform: translateY(-1px);
        }
        .trait-button.selected {
            background-color: var(--christmas-green);
            color: white;
            border-color: var(--christmas-green);
            font-weight: 600;
        }

        /* Image Placeholders */
        .image-placeholder {
            min-height: 300px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #ECFDF5; /* Green 50 */
            border: 2px dashed #A7F3D0; /* Green 200 */
            position: relative; /* Needed for absolute positioning of overlay */
        }
        .image-placeholder span {
            color: var(--christmas-green);
        }

        /* Generate Button */
        #generateBtn {
            box-shadow: 0 10px 15px -3px rgba(185, 28, 28, 0.5), 0 4px 6px -4px rgba(185, 28, 28, 0.5);
            border: 3px solid transparent;
        }
        #generateBtn:not([disabled]) {
            animation: pulse-ring 2s infinite;
            background-color: var(--christmas-red);
        }
        #generateBtn.bg-gray-300 {
            background-color: #4B5563; /* Darker disabled state for contrast */
        }
        @keyframes pulse-ring {
            0%, 100% {
                border-color: rgba(185, 28, 28, 0.3);
            }
            50% {
                border-color: rgba(185, 28, 28, 0.7);
            }
        }
        
        /* Download Button */
        #downloadBtn {
            background-color: var(--christmas-green);
        }
        #downloadBtn.bg-gray-300 {
            background-color: #4B5563;
        }

        /* Error Message */
        #errorMsg {
            background-color: #FEF2F2; /* Red 50 */
            border-color: #F87171; /* Red 400 */
            color: var(--christmas-red);
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <!-- API KEY INPUT BAR (NEW) -->
    <div id="apiKeyBar" class="mb-8 p-4 rounded-xl shadow-xl bg-yellow-100 border border-yellow-300 text-yellow-800 hidden">
        <p class="font-semibold mb-3 flex items-center">
            <i data-lucide="key" class="w-5 h-5 mr-2"></i>
            API Key Required for GitHub Pages
        </p>
        <p class="text-sm mb-3">
            To enable image generation outside of the Canvas environment, please enter your Gemini API Key below. It will only be stored in your browser's local storage.
        </p>
        <div class="flex flex-col sm:flex-row gap-3">
            <input type="password" id="apiKeyInput" placeholder="Enter your Gemini API Key here" class="flex-grow p-2 rounded-lg border border-yellow-300 text-gray-800 focus:ring-yellow-500 focus:border-yellow-500">
            <button id="saveApiKeyBtn" class="bg-yellow-600 hover:bg-yellow-700 text-white font-medium py-2 px-4 rounded-lg transition duration-150 shrink-0">
                Save Key
            </button>
        </div>
        <p id="apiKeyStatus" class="mt-2 text-sm hidden"></p>
    </div>
    <!-- END API KEY INPUT BAR -->

    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-extrabold text-main-title text-center mb-8">
            <span class="text-h2-color">LeGods</span> Christmas Wardrobe
        </h1>
        <p class="text-center text-gray-300 mb-8">Upload a LeGod or LeGoddess image</p>

        <!-- Main Grid Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <!-- 1. Controls/Upload Column (Sidebar on Desktop) -->
            <div class="lg:col-span-1 bg-card p-6 rounded-xl shadow-2xl flex flex-col h-full lg:max-h-[85vh]">
                <h2 class="text-2xl font-bold mb-4 flex items-center text-h2-color shrink-0">
                    <i data-lucide="sparkles" class="w-5 h-5 mr-2"></i>
                    Holiday Transformations
                </h2>

                <!-- Upload Section (fixed height) -->
                <div class="mb-6 border-b border-gray-300 pb-4 shrink-0">
                    <label for="imageUpload" class="block text-lg font-medium text-h3-color mb-2">1. Upload LeGod</label>
                    <input type="file" id="imageUpload" accept="image/*" class="w-full text-sm text-gray-700 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-red-50 file:text-h2-color hover:file:bg-red-100 cursor-pointer">
                </div>

                <!-- Trait Buttons Container (scrollable area, takes up remaining space) -->
                <div id="traitScrollContainer" class="flex-grow overflow-y-auto pr-2 mb-6">
                    <div id="traitControls">
                        <!-- Buttons will be dynamically generated here -->
                    </div>
                </div>

                <!-- GENERATE BUTTON (fixed at bottom) -->
                <button id="generateBtn" disabled class="w-full py-3 mt-auto text-white font-semibold rounded-lg transition duration-200 bg-gray-300 flex items-center justify-center shrink-0">
                    <i data-lucide="wand" class="w-5 h-5 mr-2"></i>
                    Generate Festive Update
                </button>
            </div>

            <!-- 2. Image Display Column -->
            <div class="lg:col-span-2 space-y-8">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">

                    <!-- Original Image -->
                    <div class="bg-card p-4 rounded-xl shadow-2xl">
                        <h2 class="text-xl font-bold mb-3 text-center text-h2-color flex items-center justify-center">
                            <i data-lucide="image" class="w-5 h-5 mr-2"></i>
                            Original Image
                        </h2>
                        <!-- MODIFIED: Added dedicated image element and placeholder ID -->
                        <div id="originalImageContainer" class="image-placeholder rounded-lg">
                            <span id="originalPlaceholder" class="text-center p-4">Upload an image to start.</span>
                            <img id="originalImage" class="w-full h-auto object-contain rounded-lg shadow-inner hidden" alt="Original Uploaded Character">
                        </div>
                    </div>

                    <!-- Generated Image -->
                    <div class="bg-card p-4 rounded-xl shadow-2xl">
                        <h2 class="text-xl font-bold mb-3 text-center text-h2-color flex items-center justify-center">
                            <i data-lucide="sparkles" class="w-5 h-5 mr-2"></i>
                            Generated Update
                        </h2>
                        <!-- Refactored Container for better performance and timer persistence -->
                        <div id="generatedImageContainer" class="image-placeholder rounded-lg">
                            
                            <!-- Status Overlay (Placeholder and Loading) -->
                            <div id="statusOverlay" class="absolute inset-0 flex flex-col justify-center items-center p-4 space-y-3">
                                <!-- Loading indicator (Hidden by default) -->
                                <div id="loadingIndicator" class="hidden text-center">
                                    <svg class="animate-spin h-8 w-8 text-main-title mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    <p class="mt-2 text-main-title font-medium">Generating your festive look...</p>
                                    <p class="text-sm text-gray-500">
                                        Estimated remaining time: 
                                        <span id="countdownDisplay" class="font-bold text-gray-400">30s</span>
                                    </p>
                                </div>
                                <!-- Placeholder Text (Visible by default) -->
                                <span id="noResultText" class="text-center p-4">Result will appear here.</span>
                            </div>

                            <!-- Result Image Element (Hidden by default) -->
                            <img id="resultImage" class="w-full h-auto object-contain rounded-lg shadow-inner hidden" alt="Generated Christmas Character">
                        </div>
                    </div>

                </div>

                <!-- Download Button and Error Message -->
                <div class="text-center pt-4">
                    <button id="downloadBtn" disabled class="px-8 py-3 bg-gray-300 text-white font-semibold rounded-lg shadow-md transition duration-200 flex items-center mx-auto">
                        <i data-lucide="download" class="w-5 h-5 mr-2"></i>
                        Download Generated Image
                    </button>
                    <!-- Improved Error Display -->
                    <p id="errorMsg" class="mt-4 font-medium p-3 rounded-lg hidden"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Application Logic (Simplified for GitHub Pages) -->
    <script type="module">
        
        let originalImageBase64 = null;
        let selectedTraits = {}; // Holds {Category: TraitKey}
        let currentApiKey = ""; // New variable to hold the active API key
        
        // Model used for image editing
        const API_MODEL = "gemini-2.5-flash-image-preview";
        // CRITICAL: Set the API Key to an empty string. This will work in the Canvas environment
        // but will require manual input on a standalone server if the hosting environment doesn't inject it.
        const API_KEY_PLACEHOLDER = ""; 

        // --- Countdown Variables ---
        let countdownInterval = null;
        const initialCountdown = 30; // Max estimated time in seconds
        let timeRemaining = initialCountdown;

        // --- DOM Elements (updated) ---
        const imageUpload = document.getElementById('imageUpload');
        const traitControls = document.getElementById('traitControls');
        const generateBtn = document.getElementById('generateBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const errorMsg = document.getElementById('errorMsg');
        
        // API Key Elements (NEW)
        const apiKeyBar = document.getElementById('apiKeyBar');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
        const apiKeyStatus = document.getElementById('apiKeyStatus');
        const API_KEY_STORAGE_KEY = 'gemini_api_key'; // Local storage key
        
        // Original Image Elements
        const originalImage = document.getElementById('originalImage');
        const originalPlaceholder = document.getElementById('originalPlaceholder');

        // Generated Image Elements
        const generatedImageContainer = document.getElementById('generatedImageContainer');
        const statusOverlay = document.getElementById('statusOverlay');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const noResultText = document.getElementById('noResultText');
        const countdownDisplay = document.getElementById('countdownDisplay');
        const resultImage = document.getElementById('resultImage');


        // --- CHRISTMAS THEMED TRAIT CONFIGURATION (EXPANDED) ---
        const TRAIT_CONFIG = {
            // Background (7 Total)
            'bg-xmas': { category: 'Background', icon: 'TreePine', label: 'Cozy Fireplace', prompt: "Change the background to a softly lit, cozy Christmas fireplace scene with stockings and a tree. Maintain the cartoon style." },
            'bg-snow': { category: 'Background', icon: 'Snowflake', label: 'Snowy Forest Night', prompt: "Change the background to a beautiful, dark snowy forest night with gentle snowfall. Maintain the cartoon style." },
            'bg-lights': { category: 'Background', icon: 'Lightbulb', label: 'Blurry Bokeh Lights', prompt: "Change the background to a blurred, colorful bokeh effect resembling out-of-focus Christmas tree lights. Maintain the cartoon style." },
            'bg-ginger': { category: 'Background', icon: 'Cookie', label: 'Gingerbread House BG', prompt: "Change background to a highly detailed, colorful gingerbread house landscape. Maintain the cartoon style." },
            'bg-aurora': { category: 'Background', icon: 'MilkyWay', label: 'Arctic Aurora Lights', prompt: "Change background to a dark, arctic sky with swirling green and blue aurora borealis lights. Maintain the cartoon style." },
            'bg-giftpile': { category: 'Background', icon: 'Package', label: 'Giant Gift Pile BG', prompt: "Change background to an enormous, colorful pile of wrapped Christmas gifts. Maintain the cartoon style." },
            'bg-garland': { category: 'Background', icon: 'Grapes', label: 'Pine Garland Border', prompt: "Add a lush, pine garland border with red ribbons framing the character. Maintain the cartoon style." },
            
            // Hat (6 Total)
            'hat-santa': { category: 'Hat', icon: 'Gift', label: 'Classic Santa Hat', prompt: "Remove any existing hat and add a classic red and white Santa Hat, placed slightly tilted. Maintain the cartoon style." },
            'hat-antlers': { category: 'Hat', icon: 'Deer', label: 'Reindeer Antlers Headband', prompt: "Remove any existing hat and add a novelty reindeer antlers headband. Maintain the cartoon style." },
            'hat-beanie': { category: 'Hat', icon: 'Beanie', label: 'Pom-Pom Beanie', prompt: "Replace hat with a chunky knit, bright red beanie with a large white pom-pom. Maintain the cartoon style." },
            'hat-crown': { category: 'Hat', icon: 'Crown', label: 'Ice Crystal Crown', prompt: "Add an intricate crown made of glittering blue ice crystals. Maintain the cartoon style." },
            'hat-elf_bells': { category: 'Hat', icon: 'BellRing', label: 'Pointy Elf Hat with Bells', prompt: "Add a traditional pointy green elf hat with tiny bells that look like they jingle. Maintain the cartoon style." },
            'hat-candle': { category: 'Hat', icon: 'Candle', label: 'Swedish Lucia Crown', prompt: "Add a Scandinavian-style wreath crown with lit candles (stylized flames). Maintain the cartoon style." },

            // Shirt (6 Total)
            'shirt-sweater': { category: 'Shirt', icon: 'Shirt', label: 'Ugly Christmas Sweater', prompt: "Remove the existing torso clothing and replace it with a hilariously ugly Christmas sweater featuring reindeer and snowmen. Maintain the cartoon style." },
            'shirt-elf': { category: 'Shirt', icon: 'Sparkles', label: 'Elf Tunic & Collar', prompt: "Remove the existing torso clothing and replace it with a green and red elf tunic and white ruffled collar. Maintain the cartoon style." },
            'shirt-robe': { category: 'Shirt', icon: 'Wreath', label: 'Red Velvet Robe', prompt: "Replace shirt with a luxurious, deep red velvet Santa robe, trimmed with white fur. Maintain the cartoon style." },
            'shirt-vest': { category: 'Shirt', icon: 'Vest', label: 'Christmas Vest', prompt: "Replace shirt with a green vest over a white button-up, embroidered with small festive icons. Maintain the cartoon style." },
            'shirt-puffer': { category: 'Shirt', icon: 'Snowflake', label: 'Festive Puffer Jacket', prompt: "Replace shirt with a shiny, red insulated puffer jacket with a snow pattern. Maintain the cartoon style." },
            'shirt-scarf': { category: 'Shirt', icon: 'Ribbon', label: 'Oversized Scarf', prompt: "Add a long, oversized red and green plaid wool scarf wrapped dramatically around the neck/torso. Maintain the cartoon style." },
            
            // Mouth (4 Total)
            'mouth-cookie': { category: 'Mouth', icon: 'Cookie', label: 'Chewing Gingerbread', prompt: "Change the mouth expression to chewing happily on a half-eaten gingerbread cookie. Maintain the cartoon style." },
            'mouth-hoho': { category: 'Mouth', icon: 'Megaphone', label: 'Yelling "Ho Ho Ho"', prompt: "Change the mouth expression to a wide, open, booming mouth, as if yelling 'Ho Ho Ho!'. Maintain the cartoon style." },
            'mouth-cocoa': { category: 'Mouth', icon: 'Coffee', label: 'Drinking Hot Cocoa', prompt: "Change the expression to sipping hot cocoa from a large mug, with a hint of foam mustache. Maintain the cartoon style." },
            'mouth-carol': { category: 'Mouth', icon: 'Music', label: 'Singing Carol Book', prompt: "Change the mouth expression to wide-open, joyful singing, holding a tiny, stylized carol book near the chin. Maintain the cartoon style." },

            // Glasses (4 Total)
            'glasses-round': { category: 'Glasses', icon: 'Glasses', label: 'Festive Red-Rimmed', prompt: "Add round, thick, festive bright red-rimmed glasses. Maintain the cartoon style." },
            'glasses-candy': { category: 'Glasses', icon: 'CandyCane', label: 'Candy Cane Stripes', prompt: "Add glasses with frames that are painted with red and white candy cane stripes. Maintain the cartoon style." },
            'glasses-snowglobe': { category: 'Glasses', icon: 'Globe', label: 'Snow Globe Glasses', prompt: "Add oversized novelty glasses where the lenses look like miniature snow globes (with tiny moving snow). Maintain the cartoon style." },
            'glasses-star': { category: 'Glasses', icon: 'Star', label: 'Star-Shaped Frames', prompt: "Add bright gold, star-shaped spectacle frames. Maintain the cartoon style." },

            // Hair (4 Total)
            'hair-tinsel': { category: 'Hair', icon: 'Sparkles', label: 'Hair Wrapped in Tinsel', prompt: "Remove the existing hair and add long, dark hair decorated with sparkly silver tinsel strands and small ornaments. Maintain the cartoon style." },
            'hair-braid': { category: 'Hair', icon: 'Ribbon', label: 'Braid with Christmas Bows', prompt: "Remove the existing hair and give the character a neat braid decorated with small red and green Christmas bows. Maintain the cartoon style." },
            'hair-lights': { category: 'Hair', icon: 'Lightbulb', label: 'Woven Christmas Lights', prompt: "Weave small, multicolored Christmas string lights into the hair, slightly glowing. Maintain the cartoon style." },
            'hair-snow': { category: 'Hair', icon: 'Snowflake', label: 'Snow-Dusted Hair', prompt: "Lightly dust the hair with a realistic layer of stylized snow and ice crystals. Maintain the cartoon style." },
            
            // New Category: Accessories (2 Total)
            'acc-earrings': { category: 'Accessories', icon: 'Earrings', label: 'Tiny Stocking Earrings', prompt: "Add dangle earrings shaped like tiny red stockings filled with gifts. Maintain the cartoon style." },
            'acc-pin': { category: 'Accessories', icon: 'Badge', label: 'Gingerbread Man Pin', prompt: "Add a small, detailed gingerbread man lapel pin on the character's clothing. Maintain the cartoon style." },

            // New Category: Handheld (2 Total)
            'hand-bell': { category: 'Handheld', icon: 'Bell', label: 'Jingle Bell', prompt: "Place a silver jingle bell held gently in the character's visible hand. Maintain the cartoon style." },
            'hand-gift': { category: 'Handheld', icon: 'Package', label: 'Wrapped Gift Box', prompt: "Place a beautifully wrapped, bow-tied gift box held in the character's visible hand. Maintain the cartoon style." }
        };


        // --- Utility Functions ---

        /**
         * Initializes the API key from local storage or defaults to the placeholder.
         * Displays the input bar if no key is found.
         */
        function initializeApiKey() {
            // Check if we are running in the Canvas environment (where the placeholder works)
            if (typeof __api_key !== 'undefined') {
                // Use the environment-provided key if available (for Canvas)
                currentApiKey = API_KEY_PLACEHOLDER;
            } else {
                // Not in Canvas, check local storage for user-provided key
                const storedKey = localStorage.getItem(API_KEY_STORAGE_KEY);
                if (storedKey) {
                    currentApiKey = storedKey;
                    apiKeyInput.value = storedKey; // Pre-fill the input
                    console.log("Using API Key from local storage.");
                } else {
                    currentApiKey = "";
                    apiKeyBar.classList.remove('hidden');
                    console.warn("No API Key found. Generation will fail until one is entered.");
                }
            }
            updateGenerateButtonState();
        }

        /**
         * Handles saving the API key from the input bar to local storage.
         */
        function handleSaveApiKey() {
            const key = apiKeyInput.value.trim();
            if (key) {
                localStorage.setItem(API_KEY_STORAGE_KEY, key);
                currentApiKey = key;
                
                apiKeyStatus.textContent = 'Key saved successfully! You can now generate images.';
                apiKeyStatus.classList.remove('hidden', 'text-red-600');
                apiKeyStatus.classList.add('text-green-600');
                
                // Hide the bar after a short delay
                setTimeout(() => {
                    apiKeyBar.classList.add('hidden');
                }, 2000);

            } else {
                apiKeyStatus.textContent = 'Please enter a valid key.';
                apiKeyStatus.classList.remove('hidden', 'text-green-600');
                apiKeyStatus.classList.add('text-red-600');
            }
            updateGenerateButtonState();
        }
        
        /**
         * Converts a File object to a Base64 data URL string.
         * @param {File} file 
         * @returns {Promise<string>}
         */
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                // Only resolve the base64 data part (after the comma)
                reader.onload = () => resolve(reader.result.split(',')[1]); 
                reader.onerror = error => reject(error);
            });
        }

        /**
         * Displays the generated image in its container.
         * @param {string} base64Data - The Base64 image data (without mime type prefix).
         */
        function displayImage(base64Data) {
            // Hide the status overlay
            statusOverlay.classList.add('hidden');
            
            // Set the image source and show the image element
            resultImage.src = `data:image/png;base64,${base64Data}`;
            resultImage.classList.remove('hidden');
        }
        
        /**
         * Displays the original uploaded image in its container.
         * @param {string} base64Data - The Base64 image data (without mime type prefix).
         */
        function displayOriginalImage(base64Data) {
            originalPlaceholder.classList.add('hidden');
            originalImage.src = `data:image/${imageUpload.files?.[0]?.type.split('/')[1] || 'png'};base64,${base64Data}`;
            originalImage.classList.remove('hidden');
        }


        /**
         * Retries a function using exponential backoff.
         * @param {Function} fn - The function to execute.
         * @param {number} maxRetries - Maximum number of retries.
         * @param {number} delay - Initial delay in ms.
         * @returns {Promise<any>}
         */
        async function withExponentialBackoff(fn, maxRetries = 5, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    const waitTime = delay * Math.pow(2, i) + Math.random() * 1000;
                    console.warn(`Request failed, retrying attempt ${i + 2}/${maxRetries} in ${Math.round(waitTime / 1000)}s...`);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
            }
        }
        
        // --- Countdown Functions ---

        /**
         * Starts the countdown timer and updates the display.
         */
        function startCountdown() {
            // Clear any existing interval
            stopCountdown();
            
            // Reset time and display
            timeRemaining = initialCountdown;
            countdownDisplay.textContent = `${timeRemaining}s`;

            countdownInterval = setInterval(() => {
                timeRemaining--;
                if (timeRemaining >= 0) {
                    countdownDisplay.textContent = `${timeRemaining}s`;
                } else {
                    // Once the countdown is complete, keep showing 0s but update the message
                    countdownDisplay.textContent = `0s (Still working...)`;
                }
            }, 1000);
        }

        /**
         * Stops the countdown timer and resets the display text.
         */
        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            // Reset the display text to the initial estimate
            if (countdownDisplay) {
                countdownDisplay.textContent = `${initialCountdown}s`;
            }
            timeRemaining = initialCountdown;
        }

        /**
         * Resets the generated image area to the initial placeholder state.
         */
        function resetGeneratedImageArea() {
            // Hide the image element
            resultImage.classList.add('hidden');
            resultImage.src = '';

            // Show the status overlay and placeholder text
            statusOverlay.classList.remove('hidden');
            noResultText.classList.remove('hidden');
            loadingIndicator.classList.add('hidden'); // Ensure spinner is off
            
            // Reset download button
            downloadBtn.disabled = true;
            downloadBtn.classList.remove('bg-christmas-green', 'hover:bg-emerald-700');
            downloadBtn.classList.add('bg-gray-300');
        }
        
        /**
         * Clears the original image display and shows the placeholder.
         */
        function clearOriginalImageArea() {
            originalImage.classList.add('hidden');
            originalImage.src = '';
            originalPlaceholder.classList.remove('hidden');
        }


        // --- Trait Controls Logic ---
        
        /**
         * Dynamically generates the trait selection buttons based on TRAIT_CONFIG.
         */
        function renderTraitControls() {
            const categories = {};
            // Group traits by category
            Object.keys(TRAIT_CONFIG).forEach(key => {
                const config = TRAIT_CONFIG[key];
                if (!categories[config.category]) {
                    categories[config.category] = [];
                }
                categories[config.category].push({ key, ...config });
            });

            // Render groups
            traitControls.innerHTML = '';
            Object.keys(categories).forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'mb-6';
                categoryDiv.innerHTML = `<h3 class="text-lg font-semibold text-h3-color mb-2">${category} (Select one)</h3>`;
                
                const buttonsDiv = document.createElement('div');
                buttonsDiv.className = 'flex flex-wrap gap-2';

                categories[category].forEach(trait => {
                    const btn = document.createElement('button');
                    btn.id = `trait-${trait.key}`;
                    btn.setAttribute('data-trait', trait.key);
                    btn.className = 'trait-button flex items-center px-3 py-1.5 text-sm font-medium rounded-full border border-gray-300 bg-gray-50 hover:bg-gray-100';
                    btn.innerHTML = `<i data-lucide="${trait.icon}" class="w-4 h-4 mr-1"></i> ${trait.label}`;
                    
                    btn.addEventListener('click', () => handleTraitSelection(trait.key));
                    buttonsDiv.appendChild(btn);
                });

                categoryDiv.appendChild(buttonsDiv);
                traitControls.appendChild(categoryDiv);
            });
            // Feather the lucide icons
            lucide.createIcons();
        }

        /**
         * Updates the state and styling of the generate button based on current selections.
         */
        function updateGenerateButtonState() {
            // New check: is API key present and valid?
            const isApiKeyReady = !!currentApiKey;
            const hasImage = !!originalImageBase64;
            const hasTraits = Object.keys(selectedTraits).length > 0;
            
            // Generation is only ready if all three conditions are met
            const isReady = isApiKeyReady && hasImage && hasTraits;

            // Update API Key Bar visibility
            if (!isApiKeyReady && API_KEY_PLACEHOLDER === "") {
                 apiKeyBar.classList.remove('hidden');
            } else {
                 apiKeyBar.classList.add('hidden');
            }

            generateBtn.disabled = !isReady;
            
            if (isReady) {
                // Enabled state: Use Christmas Red for primary action
                generateBtn.classList.remove('bg-gray-300');
                generateBtn.classList.add('bg-christmas-red', 'hover:bg-red-700');
            } else {
                // Disabled state: Visible grey color
                generateBtn.classList.remove('bg-christmas-red', 'hover:bg-red-700');
                generateBtn.classList.add('bg-gray-300');
            }
        }

        /**
         * Handles the selection/deselection of a trait button, enforcing one selection per category.
         * @param {string} traitKey 
         */
        function handleTraitSelection(traitKey) {
            const config = TRAIT_CONFIG[traitKey];
            const category = config.category;
            const buttonElement = document.getElementById(`trait-${traitKey}`);

            // Deselect previous trait in the same category, if any
            const previouslySelectedKey = selectedTraits[category];
            if (previouslySelectedKey && previouslySelectedKey !== traitKey) {
                const prevButton = document.getElementById(`trait-${previouslySelectedKey}`);
                if (prevButton) {
                    prevButton.classList.remove('selected');
                }
            }

            if (selectedTraits[category] === traitKey) {
                // Toggle off
                delete selectedTraits[category];
                buttonElement.classList.remove('selected');
            } else {
                // Select new trait
                selectedTraits[category] = traitKey;
                buttonElement.classList.add('selected');
            }
            
            updateGenerateButtonState();
        }


        // --- Image Generation Logic ---

        async function generateImage() {
            if (!originalImageBase64 || Object.keys(selectedTraits).length === 0 || !currentApiKey) {
                errorMsg.textContent = "Please upload an image, select at least one trait, and ensure your API key is saved.";
                errorMsg.classList.remove('hidden');
                console.error("Pre-check failed: Missing required inputs.");
                return;
            }

            // UI State: Loading
            errorMsg.classList.add('hidden');
            resultImage.classList.add('hidden'); // Ensure previous image is hidden
            
            // Show Status Overlay
            statusOverlay.classList.remove('hidden');
            noResultText.classList.add('hidden'); // Hide placeholder text
            loadingIndicator.classList.remove('hidden'); // Show spinner/timer

            generateBtn.disabled = true;
            downloadBtn.disabled = true;
            // Set download button to disabled styling
            downloadBtn.classList.remove('bg-christmas-green', 'hover:bg-emerald-700');
            downloadBtn.classList.add('bg-gray-300');

            
            const traitKeys = Object.keys(selectedTraits).map(cat => selectedTraits[cat]);
            
            // 1. Construct the combined prompt from all selected traits
            const basePrompt = "Using the provided cartoon character image, apply the following modifications, maintaining the existing character pose, style, and identity:";
            const traitPrompts = traitKeys.map(key => TRAIT_CONFIG[key].prompt).join(" AND ALSO ");
            const userPrompt = `${basePrompt} ${traitPrompts}`;

            // 2. Stricter system prompt enforcing safety and style
            const systemPrompt = `You are an expert cartoon editor. Your task is to modify the provided image based on the user's request. CRITICAL SAFETY AND STYLE RULES: The final output MUST be a high-quality, non-photorealistic cartoon or illustrated style image. You MUST NOT generate images of real people, explicit, or sexually suggestive content. If the input image is of a real person, or if the resulting image would violate safety policies (e.g., explicit or inappropriate), return an empty response or a policy violation message instead of generating the image. Strictly adhere to these rules.`;

            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: userPrompt },
                            {
                                inlineData: {
                                    mimeType: "image/png",
                                    data: originalImageBase64
                                }
                            }
                        ]
                    }
                ],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                }
            };

            // Start the countdown timer
            startCountdown();

            let generatedData = null;

            try {
                generatedData = await withExponentialBackoff(async () => {
                    // Use the currentApiKey variable for the API call
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${API_MODEL}:generateContent?key=${currentApiKey}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorBody = await response.json();
                        console.error("Full API Error Response:", errorBody);
                        // Check for common API key error messages (400, 403)
                        let errorMessage = errorBody.error?.message || response.statusText;
                        if (response.status === 400 || response.status === 403) {
                             errorMessage = "Authentication/API Key Error. Please ensure your key is correct and valid, and that the API is enabled for your project.";
                        }
                        throw new Error(`API Error: ${response.status} - ${errorMessage}. Check the console for full details.`);
                    }

                    const result = await response.json();
                    
                    const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;

                    if (!base64Data) {
                        throw new Error("Image generation failed. This can happen due to a content policy violation (if the input image is not a cartoon or is inappropriate), or if the model could not apply the traits successfully. Try a different input image.");
                    }
                    return base64Data;
                });
                
                displayImage(generatedData);
                
                // UI State: Success - Download logic fix confirmed
                downloadBtn.onclick = () => {
                    const a = document.createElement('a');
                    // CRITICAL: Ensure the data URI is correctly formed with the base64 prefix
                    a.href = `data:image/png;base64,${generatedData}`; 
                    a.download = `christmas-edit-${traitKeys.join('-')}-${Date.now()}.png`;
                    // Trigger download in the iFrame environment
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                };
                downloadBtn.disabled = false;
                // Set download button to enabled styling
                downloadBtn.classList.remove('bg-gray-300');
                downloadBtn.classList.add('bg-christmas-green', 'hover:bg-emerald-700');

            } catch (error) {
                console.error("Generation failed:", error);
                // UI State: Error
                errorMsg.textContent = `Generation failed: ${error.message}`;
                errorMsg.classList.remove('hidden');
                
                // Revert to placeholder text on failure
                statusOverlay.classList.remove('hidden');
                noResultText.classList.remove('hidden');
                loadingIndicator.classList.add('hidden');

                // Ensure download button remains disabled (default styling is bg-gray-300)
                downloadBtn.disabled = true;
                downloadBtn.classList.remove('bg-christmas-green', 'hover:bg-emerald-700');
                downloadBtn.classList.add('bg-gray-300');

            } finally {
                // Stop the countdown timer on finish (success or failure)
                stopCountdown(); 
                loadingIndicator.classList.add('hidden');
                updateGenerateButtonState(); // Re-enable generate if possible
            }
        }


        // --- Event Listeners and Initial Setup ---

        document.addEventListener('DOMContentLoaded', () => {
            initializeApiKey(); // Initialize the key first
            renderTraitControls();
            
            saveApiKeyBtn.addEventListener('click', handleSaveApiKey);
            apiKeyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleSaveApiKey();
                }
            });
        });

        imageUpload.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                try {
                    // Reset UI on new upload
                    errorMsg.classList.add('hidden');
                    resetGeneratedImageArea();
                    clearOriginalImageArea(); // Clear the original image display

                    if (!file.type.startsWith('image/')) {
                         throw new Error("Please upload a valid image file.");
                    }
                    
                    const base64 = await fileToBase64(file);
                    originalImageBase64 = base64;
                    
                    // Call dedicated function to display the original image
                    displayOriginalImage(base64); 
                    
                    updateGenerateButtonState();

                } catch (error) {
                    console.error("Image upload error:", error);
                    errorMsg.textContent = `File Error: ${error.message}`;
                    errorMsg.classList.remove('hidden');
                    clearOriginalImageArea(); // Clear on failure
                }
            } else {
                // Handle cancellation of file selection
                clearOriginalImageArea();
                originalImageBase64 = null;
                updateGenerateButtonState();
            }
        });
        
        generateBtn.addEventListener('click', generateImage);

    </script>
</body>
</html>

